<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1">
<meta name="generator" content="pdoc3 0.11.5">
<title>yixuan_utilities.kinematics_helper API documentation</title>
<meta name="description" content="">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/sanitize.min.css" integrity="sha512-y1dtMcuvtTMJc1yPgEqF0ZjQbhnc/bFhyvIyVNb9Zk5mIGtqVaAB1Ttl28su8AvFMOY0EwRbAe+HCLqj6W7/KA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/13.0.0/typography.min.css" integrity="sha512-Y1DYSb995BAfxobCkKepB1BqJJTPrOp3zPL74AWFugHHmmdcvO+C48WLrUOlhGMc0QG7AE3f7gmvvcrmX2fDoA==" crossorigin>
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/default.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:1.5em;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:2em 0 .50em 0}h3{font-size:1.4em;margin:1.6em 0 .7em 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .2s ease-in-out}a:visited{color:#503}a:hover{color:#b62}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900;font-weight:bold}pre code{font-size:.8em;line-height:1.4em;padding:1em;display:block}code{background:#f3f3f3;font-family:"DejaVu Sans Mono",monospace;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source > summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible;min-width:max-content}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em 1em;margin:1em 0}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul ul{padding-left:1em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js" integrity="sha512-D9gUyxqja7hBtkWpPWGt9wfbfaMGVt9gnyCvYa+jojwwPHLCzUm5i8rpk7vD7wNee9bA35eYIjobYPaQuKS1MQ==" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => {
hljs.configure({languages: ['bash', 'css', 'diff', 'graphql', 'ini', 'javascript', 'json', 'plaintext', 'python', 'python-repl', 'rust', 'shell', 'sql', 'typescript', 'xml', 'yaml']});
hljs.highlightAll();
/* Collapse source docstrings */
setTimeout(() => {
[...document.querySelectorAll('.hljs.language-python > .hljs-string')]
.filter(el => el.innerHTML.length > 200 && ['"""', "'''"].includes(el.innerHTML.substring(0, 3)))
.forEach(el => {
let d = document.createElement('details');
d.classList.add('hljs-string');
d.innerHTML = '<summary>"""</summary>' + el.innerHTML.substring(3);
el.replaceWith(d);
});
}, 100);
})</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>yixuan_utilities.kinematics_helper</code></h1>
</header>
<section id="section-intro">
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="yixuan_utilities.kinematics_helper.test_fk"><code class="name flex">
<span>def <span class="ident">test_fk</span></span>(<span>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_fk() -&gt; None:
    robot_name = &#34;trossen_vx300s_v3&#34;
    init_qpos = np.array([0, 0, 0, 0, 0, 0, 0, 0])
    end_qpos = np.array([0, -0.96, 1.16, 0, -0.3, 0, 0.09, -0.09])

    kin_helper = KinHelper(robot_name=robot_name)
    START_ARM_POSE = [0, -0.96, 1.16, 0, -0.3, 0, 0.02239, -0.02239]
    for i in range(100):
        curr_qpos = init_qpos + (end_qpos - init_qpos) * i / 100
        fk = kin_helper.compute_fk_from_link_idx(
            curr_qpos, [kin_helper.sapien_eef_idx]
        )[0]
        fk_euler = transforms3d.euler.mat2euler(fk[:3, :3], axes=&#34;sxyz&#34;)

        if i == 0:
            init_ik_qpos = np.array(START_ARM_POSE)
        ik_qpos = kin_helper.compute_ik(
            init_ik_qpos, np.array(list(fk[:3, 3]) + list(fk_euler)).astype(np.float32)
        )
        re_fk_pos_mat = kin_helper.compute_fk_from_link_idx(
            ik_qpos, [kin_helper.sapien_eef_idx]
        )[0]
        re_fk_euler = transforms3d.euler.mat2euler(re_fk_pos_mat[:3, :3], axes=&#34;sxyz&#34;)
        re_fk_pos = re_fk_pos_mat[:3, 3]
        print(&#34;re_fk_pos diff:&#34;, np.linalg.norm(re_fk_pos - fk[:3, 3]))
        print(
            &#34;re_fk_euler diff:&#34;,
            np.linalg.norm(np.array(re_fk_euler) - np.array(fk_euler)),
        )

        init_ik_qpos = ik_qpos.copy()
        print(&#34;fk_euler:&#34;, fk_euler)
        print(&#34;gt qpos:&#34;, curr_qpos)
        print(&#34;ik qpos:&#34;, ik_qpos)
        print(&#34;qpos diff:&#34;, np.linalg.norm(ik_qpos[:6] - curr_qpos[:6]))
        qpos_diff = np.linalg.norm(ik_qpos[:6] - curr_qpos[:6])
        if qpos_diff &gt; 0.01:
            logger.warning(
                &#34;qpos diff too large&#34;,
            )

        print()

        time.sleep(0.1)</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="yixuan_utilities.kinematics_helper.test_kin_helper_panda"><code class="name flex">
<span>def <span class="ident">test_kin_helper_panda</span></span>(<span>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_kin_helper_panda() -&gt; None:
    robot_name = &#34;panda&#34;
    total_steps = 100
    finger_names = None
    num_pts = None
    init_qpos = np.array(
        [
            -2.21402311,
            0.17274992,
            2.23800898,
            -2.27481246,
            -0.16332519,
            2.16096449,
            0.90828639,
            0.09,
            0.09,
        ]
    )
    end_qpos = np.array(
        [
            -2.18224038,
            0.26588862,
            2.40268749,
            -2.54840559,
            -0.2473307,
            2.33424677,
            1.19656971,
            0,
            0,
        ]
    )

    kin_helper = KinHelper(robot_name=robot_name)
    for i in range(total_steps):
        curr_qpos = init_qpos + (end_qpos - init_qpos) * i / total_steps
        fk_pose = kin_helper.compute_fk_from_link_idx(
            curr_qpos, [kin_helper.sapien_eef_idx]
        )[0]
        print(&#34;fk pose:&#34;, fk_pose)
        start_time = time.time()
        pcd = kin_helper.compute_robot_pcd(
            curr_qpos, link_names=finger_names, num_pts=num_pts, pcd_name=&#34;finger&#34;
        )
        print(&#34;compute_robot_pcd time:&#34;, time.time() - start_time)
        pcd_o3d = np2o3d(pcd)
        if i == 0:
            visualizer = o3d.visualization.Visualizer()
            visualizer.create_window()
            curr_pcd = copy.deepcopy(pcd_o3d)
            visualizer.add_geometry(curr_pcd)
            origin = o3d.geometry.TriangleMesh.create_coordinate_frame(size=0.1)
            visualizer.add_geometry(origin)
        curr_pcd.points = pcd_o3d.points
        curr_pcd.colors = pcd_o3d.colors
        visualizer.update_geometry(curr_pcd)
        visualizer.update_geometry(origin)
        visualizer.poll_events()
        visualizer.update_renderer()
        if i == 0:
            visualizer.run()</code></pre>
</details>
<div class="desc"></div>
</dd>
<dt id="yixuan_utilities.kinematics_helper.test_kin_helper_trossen"><code class="name flex">
<span>def <span class="ident">test_kin_helper_trossen</span></span>(<span>) ‑> None</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def test_kin_helper_trossen() -&gt; None:
    robot_name = &#34;trossen_vx300s_v3&#34;
    finger_names = None
    num_pts = None
    init_qpos = np.array(
        [
            0.851939865243963,
            -0.229601035617388,
            0.563932102437065,
            -0.098902024821519,
            1.148033168114365,
            1.016116677288259,
            0.0,
            -0.0,
        ]
    )
    end_qpos = np.array(
        [
            0.788165775078753,
            -0.243655597686374,
            0.573832680057706,
            -0.075632950397682,
            1.260574309772582,
            2.000622093036658,
            0.0,
            -0.0,
        ]
    )

    kin_helper = KinHelper(robot_name=robot_name)
    for i in range(100):
        curr_qpos = init_qpos + (end_qpos - init_qpos) * i / 100
        fk_pose = kin_helper.compute_fk_from_link_idx(
            curr_qpos, [kin_helper.sapien_eef_idx]
        )[0]
        print(&#34;fk pose:&#34;, fk_pose)
        start_time = time.time()
        pcd = kin_helper.compute_robot_pcd(
            curr_qpos, link_names=finger_names, num_pts=num_pts, pcd_name=&#34;finger&#34;
        )
        print(&#34;compute_robot_pcd time:&#34;, time.time() - start_time)
        pcd_o3d = np2o3d(pcd)
        if i == 0:
            visualizer = o3d.visualization.Visualizer()
            visualizer.create_window()
            curr_pcd = copy.deepcopy(pcd_o3d)
            visualizer.add_geometry(curr_pcd)
            origin = o3d.geometry.TriangleMesh.create_coordinate_frame(size=0.1)
            visualizer.add_geometry(origin)
        curr_pcd.points = pcd_o3d.points
        curr_pcd.colors = pcd_o3d.colors
        visualizer.update_geometry(curr_pcd)
        visualizer.update_geometry(origin)
        visualizer.poll_events()
        visualizer.update_renderer()
        if i == 0:
            visualizer.run()</code></pre>
</details>
<div class="desc"></div>
</dd>
</dl>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="yixuan_utilities.kinematics_helper.KinHelper"><code class="flex name class">
<span>class <span class="ident">KinHelper</span></span>
<span>(</span><span>robot_name: str = 'trossen_vx300s_tactile_thin')</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class KinHelper:
    &#34;&#34;&#34;Helper class for kinematics-related functions&#34;&#34;&#34;

    def __init__(self, robot_name: str = &#34;trossen_vx300s_tactile_thin&#34;):
        # load robot
        current_dir = Path(__file__).parent
        package_dir = (current_dir / &#34;assets&#34;).resolve()
        if &#34;trossen&#34; in robot_name:
            trossen_urdf_prefix = &#34;_&#34;.join(robot_name.split(&#34;_&#34;)[1:])
            urdf_path = (
                f&#34;{package_dir}/robot/trossen_description/{trossen_urdf_prefix}.urdf&#34;
            )
            self.eef_name = &#34;vx300s/ee_arm_link&#34;
        elif robot_name == &#34;panda&#34;:
            urdf_path = f&#34;{package_dir}/robot/panda/panda.urdf&#34;
            self.eef_name = &#34;panda_hand&#34;
        elif robot_name == &#34;pyrep_panda&#34;:
            urdf_path = f&#34;{package_dir}/robot/pyrep_panda/panda.urdf&#34;
            self.eef_name = &#34;Pandatip&#34;
        self.robot_name = robot_name
        self.urdf_robot = urdfpy.URDF.load(urdf_path)

        # load sapien robot
        self.engine = sapien.Engine()
        self.scene = self.engine.create_scene()
        loader = self.scene.create_urdf_loader()
        self.sapien_robot = loader.load(urdf_path)
        self.robot_model = self.sapien_robot.create_pinocchio_model()
        self.link_name_to_idx: dict = {}
        for link_idx, link in enumerate(self.sapien_robot.get_links()):
            self.link_name_to_idx[link.name] = link_idx
        self.sapien_eef_idx = self.link_name_to_idx[self.eef_name]

        # load meshes and offsets from urdf_robot
        self.meshes = {}
        self.scales = {}
        self.offsets = {}
        for link in self.urdf_robot.links:
            if len(link.collisions) &gt; 0:
                collision = link.collisions[0]
                if (
                    collision.geometry.mesh is not None
                    and len(collision.geometry.mesh.meshes) &gt; 0
                ):
                    mesh = collision.geometry.mesh.meshes[0]
                    self.meshes[link.name] = mesh.as_open3d
                    self.meshes[link.name].compute_vertex_normals()
                    self.meshes[link.name].paint_uniform_color([0.2, 0.2, 0.2])
                    self.scales[link.name] = (
                        collision.geometry.mesh.scale[0]
                        if collision.geometry.mesh.scale is not None
                        else 1.0
                    )
                    self.offsets[link.name] = collision.origin
        self.pcd_dict: dict = {}
        self.tool_meshes: dict = {}

    def _mesh_poses_to_pc(
        self,
        poses: np.ndarray,
        meshes: list[o3d.geometry.TriangleMesh],
        offsets: list[np.ndarray],
        num_pts: list[int],
        scales: list[int],
        pcd_name: Optional[str] = None,
    ) -&gt; np.ndarray:
        # poses: (N, 4, 4) numpy array
        # offsets: (N, ) list of offsets
        # meshes: (N, ) list of meshes
        # num_pts: (N, ) list of int
        # scales: (N, ) list of float
        try:
            assert poses.shape[0] == len(meshes)
            assert poses.shape[0] == len(offsets)
            assert poses.shape[0] == len(num_pts)
            assert poses.shape[0] == len(scales)
        except AssertionError:
            logger.critical(&#34;Input shapes do not match&#34;)
            exit(1)

        N = poses.shape[0]
        all_pc = []
        for index in range(N):
            mat = poses[index]
            if (
                pcd_name is None
                or pcd_name not in self.pcd_dict
                or len(self.pcd_dict[pcd_name]) &lt;= index
            ):
                mesh = copy.deepcopy(meshes[index])  # .copy()
                mesh.scale(scales[index], center=np.array([0, 0, 0]))
                sampled_cloud = mesh.sample_points_poisson_disk(
                    number_of_points=num_pts[index]
                )
                cloud_points = np.asarray(sampled_cloud.points)
                if pcd_name not in self.pcd_dict:
                    self.pcd_dict[pcd_name] = []
                self.pcd_dict[pcd_name].append(cloud_points)
            else:
                cloud_points = self.pcd_dict[pcd_name][index]

            tf_obj_to_link = offsets[index]

            mat = mat @ tf_obj_to_link
            transformed_points = cloud_points @ mat[:3, :3].T + mat[:3, 3]
            all_pc.append(transformed_points)
        all_pc = np.concatenate(all_pc, axis=0)
        return all_pc

    def compute_robot_pcd(
        self,
        qpos: np.ndarray,
        link_names: Optional[list[str]] = None,
        num_pts: Optional[list[int]] = None,
        pcd_name: Optional[str] = None,
    ) -&gt; np.ndarray:
        &#34;&#34;&#34;Compute point cloud of robot links given joint positions&#34;&#34;&#34;
        self.robot_model.compute_forward_kinematics(qpos)
        if link_names is None:
            link_names = list(self.meshes.keys())
        if num_pts is None:
            num_pts = [500] * len(link_names)
        link_idx_ls = []
        for link_name in link_names:
            for link_idx, link in enumerate(self.sapien_robot.get_links()):
                if link.name == link_name:
                    link_idx_ls.append(link_idx)
                    break
        link_pose_ls = np.stack(
            [
                self.robot_model.get_link_pose(link_idx).to_transformation_matrix()
                for link_idx in link_idx_ls
            ]
        )
        meshes_ls = [self.meshes[link_name] for link_name in link_names]
        offsets_ls = [self.offsets[link_name] for link_name in link_names]
        scales_ls = [self.scales[link_name] for link_name in link_names]
        pcd = self._mesh_poses_to_pc(
            poses=link_pose_ls,
            meshes=meshes_ls,
            offsets=offsets_ls,
            num_pts=num_pts,
            scales=scales_ls,
            pcd_name=pcd_name,
        )
        return pcd

    def compute_robot_meshes(
        self,
        qpos: np.ndarray,
        link_names: Optional[list[str]] = None,
    ) -&gt; list[o3d.geometry.TriangleMesh]:
        &#34;&#34;&#34;Compute meshes of robot links given joint positions&#34;&#34;&#34;
        self.robot_model.compute_forward_kinematics(qpos)
        if link_names is None:
            link_names = list(self.meshes.keys())
        link_idx_ls = []
        for link_name in link_names:
            for link_idx, link in enumerate(self.sapien_robot.get_links()):
                if link.name == link_name:
                    link_idx_ls.append(link_idx)
                    break
        link_pose_ls = np.stack(
            [
                self.robot_model.get_link_pose(link_idx).to_transformation_matrix()
                for link_idx in link_idx_ls
            ]
        )
        offsets_ls = [self.offsets[link_name] for link_name in link_names]
        meshes_ls = []
        for link_idx, link_name in enumerate(link_names):
            import copy

            mesh = copy.deepcopy(self.meshes[link_name])
            mesh.scale(0.001, center=np.array([0, 0, 0]))
            tf = link_pose_ls[link_idx] @ offsets_ls[link_idx]
            mesh.transform(tf)
            meshes_ls.append(mesh)
        return meshes_ls

    def compute_fk_from_link_idx(
        self,
        qpos: np.ndarray,
        link_idx: list[int],
    ) -&gt; list[np.ndarray]:
        &#34;&#34;&#34;Compute forward kinematics of robot links given joint positions&#34;&#34;&#34;
        self.robot_model.compute_forward_kinematics(qpos)
        link_pose_ls = []
        for i in link_idx:
            pose = self.robot_model.get_link_pose(i)
            link_pose_ls.append(pose.to_transformation_matrix())
        return link_pose_ls

    def compute_fk_from_link_names(
        self,
        qpos: np.ndarray,
        link_names: list[str],
        in_obj_frame: bool = False,
    ) -&gt; dict[str, np.ndarray]:
        &#34;&#34;&#34;Compute forward kinematics of robot links given joint positions&#34;&#34;&#34;
        self.robot_model.compute_forward_kinematics(qpos)
        link_idx_ls = [self.link_name_to_idx[link_name] for link_name in link_names]
        poses_ls = self.compute_fk_from_link_idx(qpos, link_idx_ls)
        if in_obj_frame:
            for i in range(len(link_names)):
                if link_names[i] in self.offsets:
                    poses_ls[i] = poses_ls[i] @ self.offsets[link_names[i]]
        return {link_name: pose for link_name, pose in zip(link_names, poses_ls)}

    def compute_all_fk(
        self, qpos: np.ndarray, in_obj_frame: bool = False
    ) -&gt; dict[str, np.ndarray]:
        &#34;&#34;&#34;Compute forward kinematics of all robot links given joint positions&#34;&#34;&#34;
        all_link_names = [link.name for link in self.sapien_robot.get_links()]
        return self.compute_fk_from_link_names(qpos, all_link_names, in_obj_frame)

    def compute_ik(
        self,
        initial_qpos: np.ndarray,
        cartesian: np.ndarray,
        damp: float = 1e-1,
    ) -&gt; np.ndarray:
        &#34;&#34;&#34;Compute inverse kinematics given initial joint pos and target pose&#34;&#34;&#34;
        tf_mat = np.eye(4)
        tf_mat[:3, :3] = transforms3d.euler.euler2mat(
            ai=cartesian[3], aj=cartesian[4], ak=cartesian[5], axes=&#34;sxyz&#34;
        )
        tf_mat[:3, 3] = cartesian[0:3]
        pose = sapien.Pose.from_transformation_matrix(tf_mat)
        if &#34;trossen&#34; in self.robot_name:
            active_qmask = np.array([True, True, True, True, True, True, False, False])
        elif &#34;panda&#34; in self.robot_name:
            active_qmask = np.array(
                [True, True, True, True, True, True, True, True, True]
            )
        qpos = self.robot_model.compute_inverse_kinematics(
            link_index=self.sapien_eef_idx,
            pose=pose,
            initial_qpos=initial_qpos,
            active_qmask=active_qmask,
            eps=1e-3,
            damp=damp,
        )
        # verify ik
        # fk_pose = self.compute_fk_from_link_idx(qpos[0], [self.sapien_eef_idx])[0]
        # pose_diff = np.linalg.norm(fk_pose[:3, 3] - tf_mat[:3, 3])
        # rot_diff = np.linalg.norm(fk_pose[:3, :3] - tf_mat[:3, :3])
        # if pose_diff &gt; 0.01 or rot_diff &gt; 0.01:
        #     print(&#34;ik pose diff:&#34;, pose_diff)
        #     print(&#34;ik rot diff:&#34;, rot_diff)
        #     logger.warning(&#34;ik pose diff or rot diff too large. Return initial qpos.&#34;)
        #     return initial_qpos
        return qpos[0]</code></pre>
</details>
<div class="desc"><p>Helper class for kinematics-related functions</p></div>
<h3>Methods</h3>
<dl>
<dt id="yixuan_utilities.kinematics_helper.KinHelper.compute_all_fk"><code class="name flex">
<span>def <span class="ident">compute_all_fk</span></span>(<span>self, qpos: numpy.ndarray, in_obj_frame: bool = False) ‑> dict[str, numpy.ndarray]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_all_fk(
    self, qpos: np.ndarray, in_obj_frame: bool = False
) -&gt; dict[str, np.ndarray]:
    &#34;&#34;&#34;Compute forward kinematics of all robot links given joint positions&#34;&#34;&#34;
    all_link_names = [link.name for link in self.sapien_robot.get_links()]
    return self.compute_fk_from_link_names(qpos, all_link_names, in_obj_frame)</code></pre>
</details>
<div class="desc"><p>Compute forward kinematics of all robot links given joint positions</p></div>
</dd>
<dt id="yixuan_utilities.kinematics_helper.KinHelper.compute_fk_from_link_idx"><code class="name flex">
<span>def <span class="ident">compute_fk_from_link_idx</span></span>(<span>self, qpos: numpy.ndarray, link_idx: list[int]) ‑> list[numpy.ndarray]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_fk_from_link_idx(
    self,
    qpos: np.ndarray,
    link_idx: list[int],
) -&gt; list[np.ndarray]:
    &#34;&#34;&#34;Compute forward kinematics of robot links given joint positions&#34;&#34;&#34;
    self.robot_model.compute_forward_kinematics(qpos)
    link_pose_ls = []
    for i in link_idx:
        pose = self.robot_model.get_link_pose(i)
        link_pose_ls.append(pose.to_transformation_matrix())
    return link_pose_ls</code></pre>
</details>
<div class="desc"><p>Compute forward kinematics of robot links given joint positions</p></div>
</dd>
<dt id="yixuan_utilities.kinematics_helper.KinHelper.compute_fk_from_link_names"><code class="name flex">
<span>def <span class="ident">compute_fk_from_link_names</span></span>(<span>self, qpos: numpy.ndarray, link_names: list[str], in_obj_frame: bool = False) ‑> dict[str, numpy.ndarray]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_fk_from_link_names(
    self,
    qpos: np.ndarray,
    link_names: list[str],
    in_obj_frame: bool = False,
) -&gt; dict[str, np.ndarray]:
    &#34;&#34;&#34;Compute forward kinematics of robot links given joint positions&#34;&#34;&#34;
    self.robot_model.compute_forward_kinematics(qpos)
    link_idx_ls = [self.link_name_to_idx[link_name] for link_name in link_names]
    poses_ls = self.compute_fk_from_link_idx(qpos, link_idx_ls)
    if in_obj_frame:
        for i in range(len(link_names)):
            if link_names[i] in self.offsets:
                poses_ls[i] = poses_ls[i] @ self.offsets[link_names[i]]
    return {link_name: pose for link_name, pose in zip(link_names, poses_ls)}</code></pre>
</details>
<div class="desc"><p>Compute forward kinematics of robot links given joint positions</p></div>
</dd>
<dt id="yixuan_utilities.kinematics_helper.KinHelper.compute_ik"><code class="name flex">
<span>def <span class="ident">compute_ik</span></span>(<span>self, initial_qpos: numpy.ndarray, cartesian: numpy.ndarray, damp: float = 0.1) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_ik(
    self,
    initial_qpos: np.ndarray,
    cartesian: np.ndarray,
    damp: float = 1e-1,
) -&gt; np.ndarray:
    &#34;&#34;&#34;Compute inverse kinematics given initial joint pos and target pose&#34;&#34;&#34;
    tf_mat = np.eye(4)
    tf_mat[:3, :3] = transforms3d.euler.euler2mat(
        ai=cartesian[3], aj=cartesian[4], ak=cartesian[5], axes=&#34;sxyz&#34;
    )
    tf_mat[:3, 3] = cartesian[0:3]
    pose = sapien.Pose.from_transformation_matrix(tf_mat)
    if &#34;trossen&#34; in self.robot_name:
        active_qmask = np.array([True, True, True, True, True, True, False, False])
    elif &#34;panda&#34; in self.robot_name:
        active_qmask = np.array(
            [True, True, True, True, True, True, True, True, True]
        )
    qpos = self.robot_model.compute_inverse_kinematics(
        link_index=self.sapien_eef_idx,
        pose=pose,
        initial_qpos=initial_qpos,
        active_qmask=active_qmask,
        eps=1e-3,
        damp=damp,
    )
    # verify ik
    # fk_pose = self.compute_fk_from_link_idx(qpos[0], [self.sapien_eef_idx])[0]
    # pose_diff = np.linalg.norm(fk_pose[:3, 3] - tf_mat[:3, 3])
    # rot_diff = np.linalg.norm(fk_pose[:3, :3] - tf_mat[:3, :3])
    # if pose_diff &gt; 0.01 or rot_diff &gt; 0.01:
    #     print(&#34;ik pose diff:&#34;, pose_diff)
    #     print(&#34;ik rot diff:&#34;, rot_diff)
    #     logger.warning(&#34;ik pose diff or rot diff too large. Return initial qpos.&#34;)
    #     return initial_qpos
    return qpos[0]</code></pre>
</details>
<div class="desc"><p>Compute inverse kinematics given initial joint pos and target pose</p></div>
</dd>
<dt id="yixuan_utilities.kinematics_helper.KinHelper.compute_robot_meshes"><code class="name flex">
<span>def <span class="ident">compute_robot_meshes</span></span>(<span>self, qpos: numpy.ndarray, link_names: list[str] | None = None) ‑> list[open3d.cpu.pybind.geometry.TriangleMesh]</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_robot_meshes(
    self,
    qpos: np.ndarray,
    link_names: Optional[list[str]] = None,
) -&gt; list[o3d.geometry.TriangleMesh]:
    &#34;&#34;&#34;Compute meshes of robot links given joint positions&#34;&#34;&#34;
    self.robot_model.compute_forward_kinematics(qpos)
    if link_names is None:
        link_names = list(self.meshes.keys())
    link_idx_ls = []
    for link_name in link_names:
        for link_idx, link in enumerate(self.sapien_robot.get_links()):
            if link.name == link_name:
                link_idx_ls.append(link_idx)
                break
    link_pose_ls = np.stack(
        [
            self.robot_model.get_link_pose(link_idx).to_transformation_matrix()
            for link_idx in link_idx_ls
        ]
    )
    offsets_ls = [self.offsets[link_name] for link_name in link_names]
    meshes_ls = []
    for link_idx, link_name in enumerate(link_names):
        import copy

        mesh = copy.deepcopy(self.meshes[link_name])
        mesh.scale(0.001, center=np.array([0, 0, 0]))
        tf = link_pose_ls[link_idx] @ offsets_ls[link_idx]
        mesh.transform(tf)
        meshes_ls.append(mesh)
    return meshes_ls</code></pre>
</details>
<div class="desc"><p>Compute meshes of robot links given joint positions</p></div>
</dd>
<dt id="yixuan_utilities.kinematics_helper.KinHelper.compute_robot_pcd"><code class="name flex">
<span>def <span class="ident">compute_robot_pcd</span></span>(<span>self,<br>qpos: numpy.ndarray,<br>link_names: list[str] | None = None,<br>num_pts: list[int] | None = None,<br>pcd_name: str | None = None) ‑> numpy.ndarray</span>
</code></dt>
<dd>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def compute_robot_pcd(
    self,
    qpos: np.ndarray,
    link_names: Optional[list[str]] = None,
    num_pts: Optional[list[int]] = None,
    pcd_name: Optional[str] = None,
) -&gt; np.ndarray:
    &#34;&#34;&#34;Compute point cloud of robot links given joint positions&#34;&#34;&#34;
    self.robot_model.compute_forward_kinematics(qpos)
    if link_names is None:
        link_names = list(self.meshes.keys())
    if num_pts is None:
        num_pts = [500] * len(link_names)
    link_idx_ls = []
    for link_name in link_names:
        for link_idx, link in enumerate(self.sapien_robot.get_links()):
            if link.name == link_name:
                link_idx_ls.append(link_idx)
                break
    link_pose_ls = np.stack(
        [
            self.robot_model.get_link_pose(link_idx).to_transformation_matrix()
            for link_idx in link_idx_ls
        ]
    )
    meshes_ls = [self.meshes[link_name] for link_name in link_names]
    offsets_ls = [self.offsets[link_name] for link_name in link_names]
    scales_ls = [self.scales[link_name] for link_name in link_names]
    pcd = self._mesh_poses_to_pc(
        poses=link_pose_ls,
        meshes=meshes_ls,
        offsets=offsets_ls,
        num_pts=num_pts,
        scales=scales_ls,
        pcd_name=pcd_name,
    )
    return pcd</code></pre>
</details>
<div class="desc"><p>Compute point cloud of robot links given joint positions</p></div>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="yixuan_utilities" href="index.html">yixuan_utilities</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="yixuan_utilities.kinematics_helper.test_fk" href="#yixuan_utilities.kinematics_helper.test_fk">test_fk</a></code></li>
<li><code><a title="yixuan_utilities.kinematics_helper.test_kin_helper_panda" href="#yixuan_utilities.kinematics_helper.test_kin_helper_panda">test_kin_helper_panda</a></code></li>
<li><code><a title="yixuan_utilities.kinematics_helper.test_kin_helper_trossen" href="#yixuan_utilities.kinematics_helper.test_kin_helper_trossen">test_kin_helper_trossen</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="yixuan_utilities.kinematics_helper.KinHelper" href="#yixuan_utilities.kinematics_helper.KinHelper">KinHelper</a></code></h4>
<ul class="">
<li><code><a title="yixuan_utilities.kinematics_helper.KinHelper.compute_all_fk" href="#yixuan_utilities.kinematics_helper.KinHelper.compute_all_fk">compute_all_fk</a></code></li>
<li><code><a title="yixuan_utilities.kinematics_helper.KinHelper.compute_fk_from_link_idx" href="#yixuan_utilities.kinematics_helper.KinHelper.compute_fk_from_link_idx">compute_fk_from_link_idx</a></code></li>
<li><code><a title="yixuan_utilities.kinematics_helper.KinHelper.compute_fk_from_link_names" href="#yixuan_utilities.kinematics_helper.KinHelper.compute_fk_from_link_names">compute_fk_from_link_names</a></code></li>
<li><code><a title="yixuan_utilities.kinematics_helper.KinHelper.compute_ik" href="#yixuan_utilities.kinematics_helper.KinHelper.compute_ik">compute_ik</a></code></li>
<li><code><a title="yixuan_utilities.kinematics_helper.KinHelper.compute_robot_meshes" href="#yixuan_utilities.kinematics_helper.KinHelper.compute_robot_meshes">compute_robot_meshes</a></code></li>
<li><code><a title="yixuan_utilities.kinematics_helper.KinHelper.compute_robot_pcd" href="#yixuan_utilities.kinematics_helper.KinHelper.compute_robot_pcd">compute_robot_pcd</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.11.5</a>.</p>
</footer>
</body>
</html>
